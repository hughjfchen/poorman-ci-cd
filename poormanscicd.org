#+Title: Poor Man's CI/CD System
#+Author: Chen Jin Fen
#+Date: 2024-09-20
#+OPTIONS: ^:{}
#+OPTIONS: H:9
#+OPTIONS: toc:9
#+LANG: en_US
#+PANDOC_OPTIONS: reference-doc:./reference.docx
#+PANDOC_OPTIONS: toc:t
#+PANDOC_METADATA: toc-title:Contents
#+PANDOC_VARIABLES: lang:en_US

* Goals

This is the poor man's CI/CD system and it aims to the following goals:

- Simple :: No flow, no pipeline, you know how to build your project and
  deploy it, so you just provide one script to build and the other one
  to deploy.
- Minimal :: Simple means it does not depends on other tools, it just
  uses the basic, always available tools.
- Universal :: Minimal means it can be deployed almost everywhere as the
  dependences provided.

* Design Decisions

Following the goals, it is not so hard making following design decisions:
- The source tree is the only source of truth
- The source tree should be managed by a distributed version control system
- Evertyting should be put under version control, including the CI/CD
  scripts so the source tree and the CI/CD are self-contained
- Use the universal available communicate method whenever it is needed, i.e.,
  ssh
- CI and CD should be run separatedly, that means, CD should pull the result
  of CI on the CD machine and determine if it should start or not, providing
  the CD has been deployed.

* Implementation

** Assumptions

The following assumptions are made for the implementation:
- the project need to be enabled for CI/CD has been put under a =git= repository.
- you have =root= access or passwordless =sudo= to the build and deploy machines.
- Build and Deploy uses the same git branch, that is =main=. and always
  use the latest revision of the =main= branch. So the =main= branch will be
  always buildable.
- A CI and CD script skeletion will be generated by the setup script and
  put into under the =.poormanscicd= direcotry of the same =git= repository
  as the source tree. Read the generated script skeletion carefully before
  you implement your CI/CD logic. There are some requirements for the CI/CD
  scripts.

** Procedure

***  Input

To enable an existing =git= repository for CI/CD, following inputs are needed:

#+CAPTION: Input-Parameters
#+NAME: tbl-input-parameters
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| Name                         | Required? | Value                                    | Default Value     | Remarks                                 |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| project_name                 | Yes       | detachment-system                        | N/A               | the name of the project                 |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| path_to_the_repo             | Yes       | /Users/chenjf/projects/detachment-system | N/A               | path to the project =git= repository      |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CI machine DNS or IP address | Yes       | detachment-soft.top                      | N/A               | the =DNS= or IP address of the CI machine |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CD machine DNS or IP address | Yes       | detachment-soft.top                      | N/A               | the =DNS= or IP address of the CD machine |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CI User                      | No        |                                          | ${PROJECT_NAME}ci | the user name who will do the CI job    |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CI User Password             | No        |                                          | "Passw0rd"        | the password of the CI user             |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CD User                      | No        |                                          | ${PROJECT_NAME}cd | the user name who will do the CD job    |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|
| CD User Password             | No        |                                          | "Passw0rd"        | the password of the CD user             |
|------------------------------+-----------+------------------------------------------+-------------------+-----------------------------------------|

*** Common
:PROPERTIES:
:header-args: :var PROJECT_NAME=tbl-input-parameters[3,2]
:header-args+: :var GIT_REPO_PATH=tbl-input-parameters[5,2]
:END:

As a shell script, following code should be put in front of the
script to make sure it follows some common rules:
#+NAME: common.sh
#+begin_src bash :tangle no
set -Eeuo pipefail
trap 'echo "Error occurred on line $LINENO: $BASH_COMMAND (exit code: $?)" && exit 1' ERR

guard_bash_error () {
    set -Eeuo pipefail
}

# Log levels
INFO=0
WARN=1
ERROR=2
FATAL=3
DEBUG=4
DEFAULT_LOG_LEVEL=${ERROR}

my_exit () {
    echo "$(date +"%Y-%m-%d %H:%M:%S") - EXIT: - $1"
    exit "$2"
}

msg () {
    if [ "$1" -le ${DEFAULT_LOG_LEVEL} ]; then
        echo "$(date +"%Y-%m-%d %H:%M:%S") - $2"
    fi
}

info () {
    msg ${INFO} "INFO: - $1"
}

warn () {
    msg ${WARN} "WARNING: - $1"
}

error () {
    msg ${ERROR} "ERROR: - $1"
}

fatal () {
    msg ${FATAL} "FATAL: - $1"
}

debug () {
    msg ${DEBUG} "DEBUG: - $1"
}

begin_banner () {
    info "$1 - $2 phase - begin"
}

done_banner () {
    info "$1 - $2 phase - done"
}

### turn path within script into absolute path
### must pass the calling string of the script as the first parameter
### e.g., ./path_to_script/script.sh
### or, /root/path_to_script/script.sh
### return the absolute path to the script with "echo" command
turn_to_absolute_path () {
    local SCRIPT_ABS_PATH_RAW
    SCRIPT_ABS_PATH_RAW="$(dirname "$1")"
    # turn SCRIPT_ABS_PATH into absolute path
    case ${SCRIPT_ABS_PATH_RAW} in
        /*) echo "${SCRIPT_ABS_PATH_RAW}" ;;
        \.\.*) echo "$PWD/${SCRIPT_ABS_PATH_RAW}" ;;
        \.*) echo "$PWD/${SCRIPT_ABS_PATH_RAW}" ;;
        ,*) echo "$PWD" ;;
    esac
}

### change CD to up to the project root directory
### must pass the absolute path to the script as the first parameter
change_CD_to_project_root () {
    cd "$1"
    local up_level=..
    local my_loop=10 # guard not to loop forever
    until [ -f "${up_level}/cook.sh" ] && [ ${my_loop} -gt 0 ]
    do
        up_level=${up_level}/..
        my_loop=$((my_loop - 1))
    done
    if [ ${my_loop} -eq 0 ]; then
        my_exit "Too many level up within the searching for DevOps directory,abort." 1
    fi
    cd "$1/${up_level}"
}

### check OS and distribution
### return the OS distribution and ID with "echo" command
check_dist_or_OS () {
    local MY_THE_DISTRIBUTION_ID=""
    local MY_THE_DISTRIBUTION_VERSION=""
    if [ -e /etc/os-release ]; then
        MY_THE_DISTRIBUTION_ID=$(grep -w "ID" /etc/os-release |awk -F"=" '{print $NF}'|sed 's/"//g')
        if [ "${MY_THE_DISTRIBUTION_ID}" == "ubuntu" ]; then
            MY_THE_DISTRIBUTION_VERSION=$(grep -w "VERSION_ID" /etc/os-release |awk -F"=" '{print $NF}'|sed 's/"//g')
        else
            MY_THE_DISTRIBUTION_VERSION=$(grep -w "VERSION_ID" /etc/os-release |awk -F"=" '{print $NF}'|awk -F"." '{print $1}'|sed 's/"//g')
        fi
        echo "${MY_THE_DISTRIBUTION_ID} ${MY_THE_DISTRIBUTION_VERSION}"
    else
        if type uname > /dev/null 2>&1; then
             MY_THE_DISTRIBUTION_ID=$(uname -s)
             MY_THE_DISTRIBUTION_VERSION=$(uname -r)
             echo "${MY_THE_DISTRIBUTION_ID} ${MY_THE_DISTRIBUTION_VERSION}"
        else
             echo ""
        fi
    fi
}

### guard that the caller of the script must be root or has sudo right
guard_root_or_sudo () {
    if [[ $EUID -gt 0 ]] && ! sudo -n true >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}

### init script with check if root or sudo
init_with_root_or_sudo () {
    guard_bash_error

    if ! guard_root_or_sudo; then
        my_exit "You must be root or you must be sudoer to prepare the env for CI/CD." 1
    fi

    SCRIPT_ABS_PATH=$(turn_to_absolute_path "$0")

    # change_CD_to_project_root ${SCRIPT_ABS_PATH}

    THE_DISTRIBUTION_ID_VERSION=$(check_dist_or_OS)
    THE_DISTRIBUTION_ID=$(echo "${THE_DISTRIBUTION_ID_VERSION}"|awk '{print $1}')
    THE_DISTRIBUTION_VERSION=$(echo "${THE_DISTRIBUTION_ID_VERSION}"|awk '{print $2}')
}

### init script without check if root or sudo
init_without_root_or_sudo () {
    guard_bash_error

    SCRIPT_ABS_PATH=$(turn_to_absolute_path "$0")

    # change_CD_to_project_root ${SCRIPT_ABS_PATH}

    THE_DISTRIBUTION_ID_VERSION=$(check_dist_or_OS)
    THE_DISTRIBUTION_ID=$(echo "${THE_DISTRIBUTION_ID_VERSION}"|awk '{print $1}')
    THE_DISTRIBUTION_VERSION=$(echo "${THE_DISTRIBUTION_ID_VERSION}"|awk '{print $2}')
}

null_output () {
    debug "null_output: $1"
    [ -n "$1" ] && $1 > /dev/null 2>&1
}

#+end_src

Following is the settings shared by other sections
#+NAME: Common-setting.sh
#+begin_src bash :tangle no
[ -z $PROJECT_NAME ] && my_exit "PROJECT_NAME cannot be empty" 2
[ -z $GIT_REPO_PATH ] && my_exit "GIT_REPO_PATH cannot be empty" 2

#+end_src

Following is the embedded common script snippet which can be used within a HERE DOC in a
shell script command.
#+NAME: common-embedded.sh
#+begin_src bash :tangle no
set -Eeuo pipefail

trap 'echo "Error occurred on line \$LINENO: \$BASH_COMMAND (exit code: \$?)" && exit 1' ERR

guard_bash_error () {
    set -Eeuo pipefail
}

# Log levels
INFO=0
WARN=1
ERROR=2
FATAL=3
DEBUG=4
DEFAULT_LOG_LEVEL=\${ERROR}

my_exit () {
    echo "\$(date +"%Y-%m-%d %H:%M:%S") - EXIT: - \$1"
    exit "\$2"
}

msg () {
    if [ "\$1" -le \${DEFAULT_LOG_LEVEL} ]; then
        echo "\$(date +"%Y-%m-%d %H:%M:%S") - \$2"
    fi
}

info () {
    msg \${INFO} "INFO: - \$1"
}

warn () {
    msg \${WARN} "WARNING: - \$1"
}

error () {
    msg \${ERROR} "ERROR: - \$1"
}

fatal () {
    msg \${FATAL} "FATAL: - \$1"
}

debug () {
    msg \${DEBUG} "DEBUG: - \$1"
}

begin_banner () {
    info "\$1 - \$2 phase - begin"
}

done_banner () {
    info "\$1 - \$2 phase - done"
}

### turn path within script into absolute path
### must pass the calling string of the script as the first parameter
### e.g., ./path_to_script/script.sh
### or, /root/path_to_script/script.sh
### return the absolute path to the script with "echo" command
turn_to_absolute_path () {
    local SCRIPT_ABS_PATH_RAW
    SCRIPT_ABS_PATH_RAW="\$(dirname "\$1")"
    # turn SCRIPT_ABS_PATH into absolute path
    case \${SCRIPT_ABS_PATH_RAW} in
        /*) echo "\${SCRIPT_ABS_PATH_RAW}" ;;
        \.\.*) echo "\$PWD/\${SCRIPT_ABS_PATH_RAW}" ;;
        \.*) echo "\$PWD/\${SCRIPT_ABS_PATH_RAW}" ;;
        ,*) echo "\$PWD" ;;
    esac
}

### change CD to up to the project root directory
### must pass the absolute path to the script as the first parameter
change_CD_to_project_root () {
    cd "\$1"
    local up_level=..
    local my_loop=10 # guard not to loop forever
    until [ -f "\${up_level}/cook.sh" ] && [ \${my_loop} -gt 0 ]
    do
        up_level=\${up_level}/..
        my_loop=\$((my_loop - 1))
    done
    if [ \${my_loop} -eq 0 ]; then
        my_exit "Too many level up within the searching for DevOps directory,abort." 1
    fi
    cd "\$1/\${up_level}"
}

### check OS and distribution
### return the OS distribution and ID with "echo" command
check_dist_or_OS () {
    local MY_THE_DISTRIBUTION_ID=""
    local MY_THE_DISTRIBUTION_VERSION=""
    if [ -e /etc/os-release ]; then
        MY_THE_DISTRIBUTION_ID=\$(grep -w "ID" /etc/os-release |awk -F"=" '{print \$NF}'|sed 's/"//g')
        if [ "\${MY_THE_DISTRIBUTION_ID}" == "ubuntu" ]; then
            MY_THE_DISTRIBUTION_VERSION=\$(grep -w "VERSION_ID" /etc/os-release |awk -F"=" '{print \$NF}'|sed 's/"//g')
        else
            MY_THE_DISTRIBUTION_VERSION=\$(grep -w "VERSION_ID" /etc/os-release |awk -F"=" '{print \$NF}'|awk -F"." '{print \$1}'|sed 's/"//g')
        fi
        echo "\${MY_THE_DISTRIBUTION_ID} \${MY_THE_DISTRIBUTION_VERSION}"
    else
        if type uname > /dev/null 2>&1; then
             MY_THE_DISTRIBUTION_ID=\$(uname -s)
             MY_THE_DISTRIBUTION_VERSION=\$(uname -r)
             echo "\${MY_THE_DISTRIBUTION_ID} \${MY_THE_DISTRIBUTION_VERSION}"
        else
             echo ""
        fi
    fi
}

### guard that the caller of the script must be root or has sudo right
guard_root_or_sudo () {
    if [[ \$EUID -gt 0 ]] && ! sudo -n true >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}

### init script with check if root or sudo
init_with_root_or_sudo () {
    guard_bash_error

    if ! guard_root_or_sudo; then
        my_exit "You must be root or you must be sudoer to prepare the env for CI/CD." 1
    fi

    SCRIPT_ABS_PATH=\$(turn_to_absolute_path "\$0")

    # change_CD_to_project_root \${SCRIPT_ABS_PATH}

    THE_DISTRIBUTION_ID_VERSION=\$(check_dist_or_OS)
    THE_DISTRIBUTION_ID=\$(echo "\${THE_DISTRIBUTION_ID_VERSION}"|awk '{print \$1}')
    THE_DISTRIBUTION_VERSION=\$(echo "\${THE_DISTRIBUTION_ID_VERSION}"|awk '{print \$2}')
}

### init script without check if root or sudo
init_without_root_or_sudo () {
    guard_bash_error

    SCRIPT_ABS_PATH=\$(turn_to_absolute_path "\$0")

    # change_CD_to_project_root \${SCRIPT_ABS_PATH}

    THE_DISTRIBUTION_ID_VERSION=\$(check_dist_or_OS)
    THE_DISTRIBUTION_ID=\$(echo "\${THE_DISTRIBUTION_ID_VERSION}"|awk '{print \$1}')
    THE_DISTRIBUTION_VERSION=\$(echo "\${THE_DISTRIBUTION_ID_VERSION}"|awk '{print \$2}')
}

### null the output of the given command
null_output () {
    debug "null_output: \$1"
    [ -n "\$1" ] && \$1 > /dev/null 2>&1
}

#+end_src

**** CI Server
:PROPERTIES:
:header-args+: :var CI_SERVER=tbl-input-parameters[7,2]
:header-args+: :var CI_USER=tbl-input-parameters[11,2]
:header-args+: :var CI_PASSWORD=tbl-input-parameters[13,2]
:END:

Fellowing steps must be taken on the CI server.

- prelude ::
Add following to the begining of the script to kick off a =shell script= :
#+begin_src bash :shebang #!/usr/bin/env bash :tangle scripts/setup-ci-server.sh :noweb yes
<<common.sh>>

<<common-setting.sh>>

[ -z $CI_SERVER ] && my_exit "CI_SERVER cannot be empty" 2

init_with_root_or_sudo

begin_banner "Setup CI server" "$CI_SERVER"

: ${CI_USER:=${PROJECT_NAME}ci}
: ${CI_PASSWORD:="Passw0rd"}
#+end_src

- create a CI user ::
For each project, a dedicated user would be created on the CI machine
to run the CI script.

#+begin_src  bash :tangle scripts/setup-ci-server.sh :no-expand :comments org
begin_banner "Setup CI server" "Create CI user $CI_USER"

if ! getent passwd "$CI_USER" >/dev/null 2>&1; then
  sudo useradd -m "$CI_USER" >/dev/null 2>&1
  printf "%s\n%s\n" "${CI_PASSWORD}" "${CI_PASSWORD}"| sudo passwd "$CI_USER" >/dev/null 2>&1
  [ -d /etc/sudoers.d ] && printf "%s\n" "$CI_USER ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/999-cloud-init-user-${CI_USER} > /dev/null
else
  warn "$CI_USER already exists, skip creating user"
  warn "Please make sure the user $CI_USER is the EXACT user you want to use to do the CI job."
fi

done_banner "Setup CI server" "Create CI user $CI_USER"
#+end_src

- init a bare =git= repo ::
No need to work on the source tree on the CI machine, so we only create
a =bare= git repo on the CI machine.

#+begin_src  bash :tangle scripts/setup-ci-server.sh :no-expand :comments org
begin_banner "Setup CI server" "Create server git repo"

sudo -u $CI_USER mkdir -p /home/$CI_USER/$PROJECT_NAME.git
sudo -u $CI_USER mkdir -p /home/$CI_USER/$PROJECT_NAME.work
sudo -u $CI_USER mkdir -p /home/$CI_USER/$PROJECT_NAME.build
sudo -u $CI_USER git -C /home/$CI_USER/$PROJECT_NAME.git init --bare >/dev/null 2>&1

done_banner "Setup CI server" "Create server git repo"
#+end_src

- add a =pre-receive= hook to check permission to avoid unauthorized push ::
There is a dedicated git branch *main* for =CI= build, when this branch pushed to
the =CI= machine, a =CI= build will be kicked off.

This =pre-receive= script will check permission to make sure
only listed users can push to the branch dedicated for =CI= build.

#+begin_src  bash :tangle scripts/setup-ci-server.sh :no-expand :comments org :noweb yes
begin_banner "Setup CI server" "Create a git pre-receive hook on the server git repo"

cat << _EOFPreReceive | sudo -u $CI_USER tee /home/$CI_USER/$PROJECT_NAME.git/hooks/pre-receive > /dev/null
#!/usr/bin/env bash
<<common-embedded.sh>>

# Git Hook for ban on push to ci-branch-for-$CI_SERVER branch
changedBranch=\$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')
# Add allowed users to push to ci-branch-for-$CI_SERVER
allowedUsers=($CI_USER)
if [ "\$changedBranch" == "ci-branch-for-$CI_SERVER" ]; then
  if [[ \${allowedUsers[*]} =~ \$USER ]]; then
    true
  else
    my_exit "You are not allowed push changes in the ci-branch-for-$CI_SERVER branch, only $CI_USER can do it" 1
  fi
fi
_EOFPreReceive
sudo -u $CI_USER chmod 755 /home/$CI_USER/$PROJECT_NAME.git/hooks/pre-receive

done_banner "Setup CI server" "Create a git pre-receive hook on the server git repo"
#+end_src

- add the =post-receive= hook which will checkout the work tree and call the =ci= script ::
If the dedicated =CI= build branch *main* has been pushed to the =CI= machine
by a authorized user, the =CI= build flow will be kicked off.

First, a working tree will be restored under a directory.

Then, the =CI= script within the source tree will be called to do
the real =CI= work.

#+begin_src  bash :tangle scripts/setup-ci-server.sh :no-expand :comments org :noweb yes
begin_banner "Setup CI server" "Create a git post-receive hook on the server git repo"

cat << _EOFPostReceive | sudo -u $CI_USER tee /home/$CI_USER/$PROJECT_NAME.git/hooks/post-receive > /dev/null
#!/usr/bin/env bash
<<common-embedded.sh>>

ci_branch="ci-branch-for-$CI_SERVER"
ci_branch_working_tree="/home/$CI_USER/$PROJECT_NAME.work.ci.branch"
to_build_branch_working_tree="/home/$CI_USER/$PROJECT_NAME.work.to.build.branch"
build_output="/home/$CI_USER/$PROJECT_NAME.build"
while read -r oldrev newrev refname
do
  branch=\$(git rev-parse --symbolic --abbrev-ref "\$refname")
  if [ -n "\$branch" ] && [ "\$ci_branch" = "\$branch" ]; then
    mkdir -p "\$ci_branch_working_tree"
    GIT_WORK_TREE=\$ci_branch_working_tree git checkout \$ci_branch -f >/dev/null 2>&1
    to_build_branch=\$(cat \$ci_branch_working_tree/.branch.push.to.ci.$CI_SERVER)
    to_build_rev=\$(cat \$ci_branch_working_tree/.revision.push.to.ci.$CI_SERVER)
    mkdir -p "\$to_build_branch_working_tree"
    GIT_WORK_TREE=\$to_build_branch_working_tree git checkout \$to_build_branch -f >/dev/null 2>&1
    NOW=\$(date +"%Y%m%d-%H%M%S")
    git tag "release_\$NOW" \$to_build_branch >/dev/null 2>&1
    nohup "\$to_build_branch_working_tree"/.poormanscicd/ci-$CI_SERVER.sh "\$to_build_branch_working_tree" "\$to_build_rev" "\$build_output"/ci-artifact-$PROJECT_NAME-\$to_build_branch-\$to_build_rev.tar.gz > "\$build_output"/ci.log 2>&1 &
    info "CI has been kicked off on the CI server $CI_SERVER."
    info "It will build the branch \$to_build_branch with rev \$to_build_rev"
    info "To follow the CI output, run $GIT_REPO_PATH/.poormanscicd/follow-ci-log-$CI_SERVER.sh on your local machine."
    info "To view the CI output, run $GIT_REPO_PATH/.poormanscicd/view-ci-log-$CI_SERVER.sh on your local machine."
  fi
done
_EOFPostReceive
sudo -u $CI_USER chmod 755 /home/$CI_USER/$PROJECT_NAME.git/hooks/post-receive

done_banner "Setup CI server" "Create a git post-receive hook on the server git repo"

done_banner "Setup CI server" "$CI_SERVER"
#+end_src

- unsetup ::
If you want to undo everything the script made on the CI server, just run the
following script on the CI server.

#+begin_src  bash :shebang #!/usr/bin/env bash :tangle scripts/unsetup-ci-server.sh :noweb yes
<<common.sh>>

[ -z $CI_SERVER ] && my_exit "CI_SERVER cannot be empty" 2

init_with_root_or_sudo

: ${CI_USER:=${PROJECT_NAME}ci}
: ${CI_PASSWORD:="Passw0rd"}

begin_banner "UnSetup CI server" "Unsetup CI server"

sudo userdel $CI_USER >/dev/null 2>&1
sudo rm -fr /home/$CI_USER
[ -f /etc/sudoers.d/999-cloud-init-user-${CI_USER} ] && sudo rm -fr /etc/sudoers.d/999-cloud-init-user-${CI_USER}

done_banner "UnSetup CI server" "Unsetup CI server"
#+end_src

**** CD Server
:PROPERTIES:
:header-args+: :var CD_SERVER=tbl-input-parameters[9,2]
:header-args+: :var CD_USER=tbl-input-parameters[15,2]
:header-args+: :var CD_PASSWORD=tbl-input-parameters[17,2]
:END:

- prelude ::
Add following to the begining of the script:
#+begin_src bash :shebang #!/usr/bin/env bash :tangle scripts/setup-cd-server.sh :noweb yes
<<common.sh>>

<<common-setting.sh>>

[ -z $CD_SERVER ] && my_exit "CD_SERVER cannot be empty" 2

init_with_root_or_sudo

begin_banner "Setup CD server" "$CD_SERVER"

: ${CD_USER:=${PROJECT_NAME}cd}
: ${CD_PASSWORD:="Passw0rd"}
#+end_src

This part is optional.

Felloing steps must be taken on the CD server.

- create a CD user ::
A dedicated user would be created on the CD machine to run the CD script.
Following is the command:

#+begin_src  bash :tangle scripts/setup-cd-server.sh :no-expand
begin_banner "Setup CD server" "Create CD user $CD_USER"

if ! getent passwd "$CD_USER" >/dev/null 2>&1; then
  sudo useradd -m "$CD_USER" >/dev/null 2>&1

  printf "%s\n%s\n" "$CD_PASSWORD" "$CD_PASSWORD" | sudo passwd "$CD_USER" >/dev/null 2>&1
  [ -d /etc/sudoers.d ] && printf "%s\n" "$CD_USER ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/999-cloud-init-user-${CD_USER} > /dev/null
else
  printf "%s\n" "$CD_USER already exists, skip creating user"
  printf "%s\n" "Please make sure the user $CD_USER is the EXACT user you want to use to do the CD job."
fi

done_banner "Setup CD server" "Create CD user $CD_USER"
#+end_src

- init a bare =git= repo ::
run the following command:
#+begin_src  bash :tangle scripts/setup-cd-server.sh :no-expand
begin_banner "Setup CD server" "Create server git repo"

sudo -u $CD_USER mkdir -p /home/$CD_USER/$PROJECT_NAME.git
sudo -u $CD_USER mkdir -p /home/$CD_USER/$PROJECT_NAME.work
sudo -u $CD_USER mkdir -p /home/$CD_USER/$PROJECT_NAME.build
sudo -u $CD_USER mkdir -p /home/$CD_USER/$PROJECT_NAME.deploy
sudo -u $CD_USER git -C /home/$CD_USER/$PROJECT_NAME.git init --bare >/dev/null 2>&1

done_banner "Setup CD server" "Create server git repo"
#+end_src

- add a =pre-receive= hook to check permission to avoid unauthorized push ::
#+begin_src  bash :tangle scripts/setup-cd-server.sh :no-expand :noweb yes
begin_banner "Setup CD server" "Create a git pre-receive hook on the server git repo"

# Git Hook for ban on push to main branch
cat << _EOFPreReceive | sudo -u $CD_USER tee /home/$CD_USER/$PROJECT_NAME.git/hooks/pre-receive > /dev/null
#!/usr/bin/env bash
<<common-embedded.sh>>

changedBranch=\$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')
# Add allowed users to push to cd-branch-for-$CD_SERVER
allowedUsers=($CD_USER)
if [ "\$changedBranch" == "cd-branch-for-$CD_SERVER" ]; then
  if [[ \${allowedUsers[*]} =~ \$USER ]]; then
    true
  else
    my_exit "You are not allowed to push changes to the cd-branch-for-$CD_SERVER branch, only $CD_USER can do it" 1
  fi
fi
_EOFPreReceive
sudo -u $CD_USER chmod 755 /home/$CD_USER/$PROJECT_NAME.git/hooks/pre-receive

done_banner "Setup CD server" "Create a git pre-receive hook on the server git repo"
#+end_src

- add the =post-reveive= hook which will checkout the work tree and call the =ci= script ::

#+begin_src  bash :tangle scripts/setup-cd-server.sh :no-expand :noweb yes
begin_banner "Setup CD server" "Create a git post-receive hook on the server git repo"

cat << _EOFPostReceive | sudo -u $CD_USER tee /home/$CD_USER/$PROJECT_NAME.git/hooks/post-receive > /dev/null
#!/usr/bin/env bash
<<common-embedded.sh>>

cd_branch="cd-branch-for-$CD_SERVER"
cd_branch_working_tree="/home/$CD_USER/$PROJECT_NAME.work.cd.branch"
to_deploy_branch_working_tree="/home/$CD_USER/$PROJECT_NAME.work.to.deploy.branch"
build_output="/home/$CD_USER/$PROJECT_NAME.build"
deploy_output="/home/$CD_USER/$PROJECT_NAME.deploy"
while read -r oldrev newrev refname
do
  branch=\$(git rev-parse --symbolic --abbrev-ref "\$refname")
  if [ -n "\$branch" ] && [ "\$cd_branch" = "\$branch" ]; then
    mkdir -p "\$cd_branch_working_tree"
    GIT_WORK_TREE=\$cd_branch_working_tree git checkout \$cd_branch -f >/dev/null 2>&1
    to_deploy_branch=\$(cat \$cd_branch_working_tree/.branch.push.to.cd.$CD_SERVER)
    to_deploy_rev=\$(cat \$cd_branch_working_tree/.revision.push.to.cd.$CD_SERVER)
    mkdir -p "\$to_deploy_branch_working_tree"
    GIT_WORK_TREE=\$to_deploy_branch_working_tree git checkout \$to_deploy_branch -f >/dev/null 2>&1
    NOW=\$(date +"%Y%m%d-%H%M%S")
    git tag "release_\$NOW" \$to_deploy_branch >/dev/null 2>&1
    nohup "\$to_deploy_branch_working_tree"/.poormanscicd/cd-$CD_SERVER.sh "\$to_deploy_branch_working_tree" "\$to_deploy_rev" "\$build_output"/ci-artifact-$PROJECT_NAME-\$to_deploy_branch-\$to_deploy_rev.tar.gz > "\$deploy_output"/cd.log 2>&1 &
    info "CD has been kicked off on the CD server $CD_SERVER."
    info "It will deploy the branch \$to_deploy_branch with rev \$to_deploy_rev"
    info "To follow the CD output, run $GIT_REPO_PATH/.poormanscicd/follow-cd-log-$CD_SERVER.sh on your local machine."
    info "To view the CD output, run $GIT_REPO_PATH/.poormanscicd/view-cd-log-$CD_SERVER.sh on your local machine."
  fi
done
_EOFPostReceive
sudo -u $CD_USER chmod 755 /home/$CD_USER/$PROJECT_NAME.git/hooks/post-receive

done_banner "Setup CD server" "Create a git post-receive hook on the server git repo"

done_banner "Setup CD server" "$CD_SERVER"
#+end_src

- unsetup ::
If you want to undo everything the script made on the CI server, just run the
following script on the CI server.

#+begin_src  bash :shebang #!/usr/bin/env bash :tangle scripts/unsetup-cd-server.sh :noweb yes
<<common.sh>>

[ -z $CD_SERVER ] && my_exit "CD_SERVER cannot be empty" 2

init_with_root_or_sudo

: ${CD_USER:=${PROJECT_NAME}cd}
: ${CD_PASSWORD:="Passw0rd"}

begin_banner "UnSetup CD server" "Unsetup CD server"

sudo userdel $CD_USER >/dev/null 2>&1
sudo rm -fr /home/$CD_USER
[ -f /etc/sudoers.d/999-cloud-init-user-${CD_USER} ] && sudo rm -fr /etc/sudoers.d/999-cloud-init-user-${CD_USER}

done_banner "UnSetup CD server" "Unsetup CD server"
#+end_src

**** Client Side
:PROPERTIES:
:header-args+: :var CI_SERVER=tbl-input-parameters[7,2]
:header-args+: :var CD_SERVER=tbl-input-parameters[9,2]
:header-args+: :var CI_USER=tbl-input-parameters[11,2]
:header-args+: :var CI_PASSWORD=tbl-input-parameters[13,2]
:header-args+: :var CD_USER=tbl-input-parameters[15,2]
:header-args+: :var CD_PASSWORD=tbl-input-parameters[17,2]
:END:

The client side means the machine where the =git= repository is located, and
following actions must be taken:

- prelude ::
Add following to the begining of the script:
#+begin_src bash :shebang #!/usr/bin/env bash :tangle scripts/setup-cicd-local.sh :noweb yes
<<common.sh>>

<<common-setting.sh>>

[ -z $CI_SERVER ] && my_exit "CI_SERVER cannot be empty" 2
[ -z $CD_SERVER ] && my_exit "CD_SERVER cannot be empty" 2

begin_banner "Setup local development environment" "local"

: ${CI_USER:=${PROJECT_NAME}ci}
: ${CI_PASSWORD:="Passw0rd"}
: ${CD_USER:=${PROJECT_NAME}cd}
: ${CD_PASSWORD:="Passw0rd"}
#+end_src

- generate a =ssh= key for the dedicated user accessing to the CI/CD machines with following command ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "generate ssh keys to access CI/CD server"

[ -f ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER ] || ssh-keygen -t rsa -b 4096 -C "$CI_USER@$CI_SERVER" -f ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER
[ -f ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER ] || ssh-keygen -t rsa -b 4096 -C "$CD_USER@$CD_SERVER" -f ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER

done_banner "Setup local development environment" "generate ssh keys to access CI/CD server"
#+end_src

- copy the generated =ssh= key to the CI/CD machine so that the user can login without password ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "copy ssh keys to CI/CD server"

# the printf tips does not work any more because ssh command
# read input from terminal directory instead from stdin
if type -p sshpass > /dev/null 2>&1; then
  sshpass -p "$CI_PASSWORD" ssh-copy-id -i ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER "$CI_USER"@"$CI_SERVER" >/dev/null 2>&1
  sshpass -p "$CD_PASSWORD" ssh-copy-id -i ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER "$CD_USER"@"$CD_SERVER" >/dev/null 2>&1
else
  ssh-copy-id -i ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER "$CI_USER"@"$CI_SERVER"
  ssh-copy-id -i ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER "$CD_USER"@"$CD_SERVER"
fi

done_banner "Setup local development environment" "copy ssh keys to CI/CD server"
#+end_src

- config =ssh= config to make sure the dedicated user login with the generated key to the CI/CD machine ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "add ssh config to access CI/CD server"

function add_CI_to_ssh_config() {
cat << _SSH_CONFIG_FOR_CI > ~/.ssh/config

Host $CI_SERVER
  StrictHostKeyChecking accept-new
  User $CI_USER
  IdentityFile ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER
  IdentitiesOnly yes
_SSH_CONFIG_FOR_CI
}
function add_CD_to_ssh_config() {
cat << _SSH_CONFIG_FOR_CD > ~/.ssh/config

Host $CD_SERVER
  StrictHostKeyChecking accept-new
  User $CD_USER
  IdentityFile ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER
  IdentitiesOnly yes
_SSH_CONFIG_FOR_CD
}

function append_CI_to_ssh_config() {
cat << _SSH_CONFIG_FOR_CI >> ~/.ssh/config

Host $CI_SERVER
  StrictHostKeyChecking accept-new
  User $CI_USER
  IdentityFile ~/.ssh/id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER
  IdentitiesOnly yes
_SSH_CONFIG_FOR_CI
}
function append_CD_to_ssh_config () {
cat << _SSH_CONFIG_FOR_CD >> ~/.ssh/config

Host $CD_SERVER
  StrictHostKeyChecking accept-new
  User $CD_USER
  IdentityFile ~/.ssh/id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER
  IdentitiesOnly yes
_SSH_CONFIG_FOR_CD
}

if [ -f ~/.ssh/config ]; then
  if grep "id_rsa.${PROJECT_NAME}_CI_at_$CI_SERVER" ~/.ssh/config >/dev/null 2>&1; then
    true
  else
    append_CI_to_ssh_config
  fi
  if grep "id_rsa.${PROJECT_NAME}_CD_at_$CD_SERVER" ~/.ssh/config >/dev/null 2>&1; then
    true
  else
    append_CD_to_ssh_config
  fi
else
  mkdir -p ~/.ssh
  add_CI_to_ssh_config
  add_CD_to_ssh_config
fi

done_banner "Setup local development environment" "add ssh config to access CI/CD server"
#+end_src

- define a =git= remote and a branch to push the =main= source tree branch to the CI machine ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "add CI/CD remote to the git repo"

git -C "$GIT_REPO_PATH" remote get-url ci-at-$CI_SERVER >/dev/null 2>&1 && git -C "$GIT_REPO_PATH" remote remove ci-at-$CI_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" remote add ci-at-$CI_SERVER ssh://$CI_USER@$CI_SERVER:/home/$CI_USER/$PROJECT_NAME.git >/dev/null 2>&1
git -C "$GIT_REPO_PATH" remote get-url cd-at-$CD_SERVER >/dev/null 2>&1 && git -C "$GIT_REPO_PATH" remote remove cd-at-$CD_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" remote add cd-at-$CD_SERVER ssh://$CD_USER@$CD_SERVER:/home/$CD_USER/$PROJECT_NAME.git >/dev/null 2>&1

git -C "$GIT_REPO_PATH" rev-parse --verify ci-branch-for-$CI_SERVER >/dev/null 2>&1 || git branch ci-branch-for-$CI_SERVER >/dev/null 2>&1

git -C "$GIT_REPO_PATH" rev-parse --verify cd-branch-for-$CD_SERVER >/dev/null 2>&1 || git branch cd-branch-for-$CD_SERVER >/dev/null 2>&1

[ -d $GIT_REPO_PATH/.poormanscicd ] || mkdir -p $GIT_REPO_PATH/.poormanscicd

done_banner "Setup local development environment" "add CI/CD remote to the git repo"
#+end_src

- generate =push-to-ci.sh= under the given =git= repository ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand :noweb yes
begin_banner "Setup local development environment" "generate push-to-ci script"

cat << _PUSH_TO_CI_SCRIPT > $GIT_REPO_PATH/.poormanscicd/push-to-ci-$CI_SERVER.sh
#!/usr/bin/env bash
<<common-embedded.sh>>

# this script accept one optional parameters, the branch
# to push to the CI server for build
# If no optional parameter given, defaul value will be used

: "\${BRANCH_TO_PUSH:=main}"

[ -n "\${1-}" ] && BRANCH_TO_PUSH="\$1"

: "\${REV_TO_PUSH:=\$(git -C "$GIT_REPO_PATH" rev-parse \$BRANCH_TO_PUSH)}"

[ -n "\${2-}" ] && REV_TO_PUSH="\$2"

if git -C "$GIT_REPO_PATH" rev-parse --verify \$BRANCH_TO_PUSH >/dev/null 2>&1; then
  true
else
  my_exit "branch \$BRANCH_TO_PUSH not exists, abort." 113
fi

# must check if the rev exists in the given branch
BRANCH_WITH_THE_REV=\$(git -C "$GIT_REPO_PATH" branch --contains \$REV_TO_PUSH | grep -w \$BRANCH_TO_PUSH)
if [ "\${BRANCH_WITH_THE_REV}"=="\${BRANCH_TO_PUSH}" ]; then
  true
else
  my_exit "Branch \$BRANCH_TO_PUSH does not contain Revision \$REV_TO_PUSH, abort." 112
fi

# push the specificed branch and rev to the CI server first
begin_banner "push to CI" "push branch \$BRANCH_TO_PUSH"
git -C "$GIT_REPO_PATH" push ci-at-$CI_SERVER "\$BRANCH_TO_PUSH" >/dev/null 2>&1
done_banner "push to CI" "push branch \$BRANCH_TO_PUSH"

# now switch to the CI branch and
# update the timestamp, then push to the CI
# server to trigger the build

: "\${CURRENT_BRANCH:=\$(git -C "$GIT_REPO_PATH" branch --show-current)}"
[ -z "\${CURRENT_BRANCH}" ] && CURRENT_BRANCH="\$BRANCH_TO_PUSH"

git -C "$GIT_REPO_PATH" checkout ci-branch-for-$CI_SERVER >/dev/null 2>&1

echo "\$(date +%Y%m%d%H%M%S)" > $GIT_REPO_PATH/.timestamp.push.to.ci.$CI_SERVER
echo "\$BRANCH_TO_PUSH" > $GIT_REPO_PATH/.branch.push.to.ci.$CI_SERVER
echo "\$REV_TO_PUSH" > $GIT_REPO_PATH/.revision.push.to.ci.$CI_SERVER

git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.timestamp.push.to.ci.$CI_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.branch.push.to.ci.$CI_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.revision.push.to.ci.$CI_SERVER >/dev/null 2>&1

git -C "$GIT_REPO_PATH" commit -m "update timestamp, branch and revision to push and trigger CI for $CI_SERVER" >/dev/null 2>&1

# that would trigger the CI build
begin_banner "push to CI" "push branch ci-branch-for-$CI_SERVER to trigger CI"
git -C "$GIT_REPO_PATH" push ci-at-$CI_SERVER ci-branch-for-$CI_SERVER >/dev/null 2>&1
done_banner "push to CI" "push branch ci-branch-for-$CI_SERVER to trigger CI"

git -C "$GIT_REPO_PATH" checkout \$CURRENT_BRANCH >/dev/null 2>&1

info "CI has been kicked off on the CI server $CI_SERVER."
info "It will build the branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"
info "To follow the CI output, run $GIT_REPO_PATH/.poormanscicd/follow-ci-log-$CI_SERVER.sh on your local machine."
info "To view the CI output, run $GIT_REPO_PATH/.poormanscicd/view-ci-log-$CI_SERVER.sh on your local machine."

_PUSH_TO_CI_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/push-to-ci-$CI_SERVER.sh

done_banner "Setup local development environment" "generate push-to-ci script"
#+end_src

- generate =push-to-cd.sh= under the given =git= repository if CD is specificed ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand :noweb yes
begin_banner "Setup local development environment" "generate push-to-cd script"

if [ -n "$CD_SERVER" ]; then
cat << _PUSH_TO_CD_SCRIPT > $GIT_REPO_PATH/.poormanscicd/push-to-cd-$CD_SERVER.sh
#!/usr/bin/env bash
<<common-embedded.sh>>

# this script accept one optional parameters, the branch
# to push to the CI server for build
# If no optional parameter given, defaul value will be used

: "\${BRANCH_TO_PUSH:=main}"

[ -n "\${1-}" ] && BRANCH_TO_PUSH="\$1"

: "\${REV_TO_PUSH:=\$(git -C "$GIT_REPO_PATH" rev-parse \$BRANCH_TO_PUSH)}"

[ -n "\${2-}" ] && REV_TO_PUSH="\$2"

if git -C "$GIT_REPO_PATH" rev-parse --verify \$BRANCH_TO_PUSH >/dev/null 2>&1; then
  true
else
  my_exit "branch \$BRANCH_TO_PUSH not exists, abort." 113
fi

# must check if the rev exists in the given branch
BRANCH_WITH_THE_REV=\$(git -C "$GIT_REPO_PATH" branch --contains \$REV_TO_PUSH | grep -w \$BRANCH_TO_PUSH)
if [ "\${BRANCH_WITH_THE_REV}"=="\${BRANCH_TO_PUSH}" ]; then
  true
else
  my_exit "Branch \$BRANCH_TO_PUSH does not contain Revision \$REV_TO_PUSH, abort." 112
fi

# there must exist a CI server for CD
# afterall, deployment need the build artifact
[ -z "$CI_SERVER" ] && my_exist "For CD to work, the CI_SERVER cannot be empty." 178

# download the build artifact and then upload to the CD server
# to let the deployment run
ci_build_output="/home/$CI_USER/$PROJECT_NAME.build"
cd_build_output="/home/$CD_USER/$PROJECT_NAME.build"
cd_deploy_output="/home/$CD_USER/$PROJECT_NAME.deploy"
begin_banner "trying to find the build artifacat on the CI server $CI_SERVER" "branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"
if ssh ${CI_USER}@$CI_SERVER test -f \$ci_build_output/ci-artifact-$PROJECT_NAME-\$BRANCH_TO_PUSH-\$REV_TO_PUSH.tar.gz; then
   info "Found the build artifact for the branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"

   begin_banner "trying to copy the build artifacat to CD server $CD_SERVER from CI server $CI_SERVER" "branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"
   TEMP_CI_ARTIFACT=\$(mktemp -d -t ci-artifact-$PROJECT_NAME.xxxx)
   scp $CI_USER@$CI_SERVER:\$ci_build_output/ci-artifact-$PROJECT_NAME-\$BRANCH_TO_PUSH-\$REV_TO_PUSH.tar.gz \$TEMP_CI_ARTIFACT/
   scp \$TEMP_CI_ARTIFACT/ci-artifact-$PROJECT_NAME-\$BRANCH_TO_PUSH-\$REV_TO_PUSH.tar.gz $CD_USER@$CD_SERVER:\$cd_build_output/
   rm -fr \$TEMP_CI_ARTIFACT
   done_banner "trying to copy the build artifacat to CD server $CD_SERVER from CI server $CI_SERVER" "branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"

   info "build artifact is available as \$cd_build_output/ci-artifact-$PROJECT_NAME-\$BRANCH_TO_PUSH-\$REV_TO_PUSH.tar.gz on the machine $CD_SERVER"
else
   error "cannot found the CI artifact for \$BRANCH_TO_PUSH branch revision \$REV_TO_PUSH on the CI server $CI_SERVER."
   error "please run the command '$GIT_REPO_PATH/.poormanscicd/push-to-ci-$CI_SERVER.sh \$BRANCH_TO_PUSH \$REV_TO_PUSH' to build the project before you can deploy."
   my_exit "abort deployment." 111
fi

done_banner "trying to find the build artifacat on the CI server $CI_SERVER" "branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"

# push the specificed branch and rev to the CD server first
begin_banner "push to CD" "push branch \$BRANCH_TO_PUSH"
git -C "$GIT_REPO_PATH" push cd-at-$CD_SERVER "\$BRANCH_TO_PUSH" >/dev/null 2>&1
done_banner "push to CD" "push branch \$BRANCH_TO_PUSH"

# now switch to the CD branch and
# update the timestamp, then push to the CD
# server to trigger the deployment

: "\${CURRENT_BRANCH:=\$(git -C "$GIT_REPO_PATH" branch --show-current)}"
[ -z "\${CURRENT_BRANCH}" ] && CURRENT_BRANCH="\$BRANCH_TO_PUSH"

git -C "$GIT_REPO_PATH" checkout cd-branch-for-$CD_SERVER >/dev/null 2>&1

echo "\$(date +%Y%m%d%H%M%S)" > $GIT_REPO_PATH/.timestamp.push.to.cd.$CD_SERVER
echo "\$BRANCH_TO_PUSH" > $GIT_REPO_PATH/.branch.push.to.cd.$CD_SERVER
echo "\$REV_TO_PUSH" > $GIT_REPO_PATH/.revision.push.to.cd.$CD_SERVER

git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.timestamp.push.to.cd.$CD_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.branch.push.to.cd.$CD_SERVER >/dev/null 2>&1
git -C "$GIT_REPO_PATH" add $GIT_REPO_PATH/.revision.push.to.cd.$CD_SERVER >/dev/null 2>&1

git -C "$GIT_REPO_PATH" commit -m "update timestamp, branch and revision to push and trigger CD for $CD_SERVER" >/dev/null 2>&1

# that would trigger the CD deployment
begin_banner "push to CD" "push branch cd-branch-for-$CD_SERVER"
git -C "$GIT_REPO_PATH" push cd-at-$CD_SERVER cd-branch-for-$CD_SERVER >/dev/null 2>&1
done_banner "push to CD" "push branch cd-branch-for-$CD_SERVER"

git -C "$GIT_REPO_PATH" checkout \$CURRENT_BRANCH >/dev/null 2>&1

info "CD has been kicked off on the CD server $CD_SERVER."
info "It will deploy the branch \$BRANCH_TO_PUSH with rev \$REV_TO_PUSH"
info "To follow the CD output, run $GIT_REPO_PATH/.poormanscicd/follow-cd-log-$CD_SERVER.sh on your local machine."
info "To view the CD output, run $GIT_REPO_PATH/.poormanscicd/view-cd-log-$CD_SERVER.sh on your local machine."

_PUSH_TO_CD_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/push-to-cd-$CD_SERVER.sh

done_banner "Setup local development environment" "generate push-to-cd script"
fi
#+end_src

- generate =follow-ci-log.sh= under the given =git= repository ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "generate follow-ci-log script"

cat << _FOLLOW_CI_LOG_SCRIPT > $GIT_REPO_PATH/.poormanscicd/follow-ci-log-$CI_SERVER.sh
ci_build_output="/home/$CI_USER/$PROJECT_NAME.build"
ssh $CI_USER@$CI_SERVER tail -f \$ci_build_output/ci.log
_FOLLOW_CI_LOG_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/follow-ci-log-$CI_SERVER.sh
cat << _FOLLOW_CD_LOG_SCRIPT > $GIT_REPO_PATH/.poormanscicd/follow-cd-log-$CD_SERVER.sh
cd_deploy_output="/home/$CD_USER/$PROJECT_NAME.deploy"
ssh $CD_USER@$CD_SERVER tail -f \$cd_deploy_output/cd.log
_FOLLOW_CD_LOG_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/follow-cd-log-$CD_SERVER.sh

done_banner "Setup local development environment" "generate follow-ci-log script"
#+end_src

- generate =view-ci-log.sh= under the given =git= repository ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand
begin_banner "Setup local development environment" "generate view-ci-log script"

cat << _VIEW_CI_LOG_SCRIPT > $GIT_REPO_PATH/.poormanscicd/view-ci-log-$CI_SERVER.sh
ci_build_output="/home/$CI_USER/$PROJECT_NAME.build"
ssh $CI_USER@$CI_SERVER cat \$ci_build_output/ci.log
_VIEW_CI_LOG_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/view-ci-log-$CI_SERVER.sh
cat << _VIEW_CD_LOG_SCRIPT > $GIT_REPO_PATH/.poormanscicd/view-cd-log-$CD_SERVER.sh
cd_deploy_output="/home/$CD_USER/$PROJECT_NAME.deploy"
ssh $CD_USER@$CD_SERVER cat \$cd_deploy_output/cd.log
_VIEW_CD_LOG_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/view-cd-log-$CD_SERVER.sh

done_banner "Setup local development environment" "generate view-ci-log script"
#+end_src

- generate =ci.sh= and =cd.sh= skeletion script under the =.poormanscicd= directory of the given =git= repository ::

#+begin_src  bash :tangle scripts/setup-cicd-local.sh :no-expand :noweb yes
begin_banner "Setup local development environment" "generate ci/cd script template"

cat << _CI_TEMPLATE_SCRIPT > $GIT_REPO_PATH/.poormanscicd/ci-$CI_SERVER.sh
#!/usr/bin/env bash
<<common-embedded.sh>>

# this script will be fed with three parameters when being invoked:
# \$1 - the working tree directory of the git repository
# \$2 - the revision hash of the git repository
# \$3 - the full path of the build artifact tarball
# This script should tar up the build result and put to the location
# of the \$3

: "\${WORKING_TREE:=.}"
[ -n "\${1-}" ] && WORKING_TREE="\$1"

: "\${GIT_REV:=HEAD}"
[ -n "\${2-}" ] && GIT_REV="\$2"

: "\${BUILD_TARBALL:=ci-artifact-$PROJECT_NAME-\$GIT_REV.tar.gz}"
[ -n "\${3-}" ] && BUILD_TARBALL="\$3"

######## Put the CI commands below ######
info "Please add your own CI commands in the $GIT_REPO_PATH/.poormanscicd/ci-$CI_SERVER.sh"

#### the last step is to tar up the build result and dave to \$3 ###
touch "\${BUILD_TARBALL}"

_CI_TEMPLATE_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/ci-$CI_SERVER.sh
cat << _CD_TEMPLATE_SCRIPT > $GIT_REPO_PATH/.poormanscicd/cd-$CD_SERVER.sh
#!/usr/bin/env bash
<<common-embedded.sh>>

# this script will be fed with three parameters when being invoked:
# \$1 - the working tree directory of the git repository
# \$2 - the revision hash of the git repository
# \$3 - the full path of the build artifact tarball
# This script should read the build tarball from the localtion of \$3

: "\${WORKING_TREE:=.}"
[ -n "\${1-}" ] && WORKING_TREE="\$1"

: "\${GIT_REV:=HEAD}"
[ -n "\${2-}" ] && GIT_REV="\$2"

: "\${BUILD_TARBALL:=ci-artifact-$PROJECT_NAME-\$GIT_REV.tar.gz}"
[ -n "\${3-}" ] && BUILD_TARBALL="\$3"

######## Put the CD commands below ######
info "Please add your own CD commands in the $GIT_REPO_PATH/.poormanscicd/cd-$CD_SERVER.sh"

info "build tarball: \$BUILD_TARBALL"

_CD_TEMPLATE_SCRIPT
chmod 755 $GIT_REPO_PATH/.poormanscicd/cd-$CD_SERVER.sh
set -u

done_banner "Setup local development environment" "generate ci/cd script template"

done_banner "Setup local development environment" "local"

info "The local git repo $GIT_REPO_PATH has been setup for CI/CD"
info "Whenever you want to do CI, just run '$GIT_REPO_PATH/.poormanscicd/push-to-ci-$CI_SERVER.sh'"
info "And CD, just run '$GIT_REPO_PATH/.poormanscicd/push-to-cd-$CD_SERVER.sh'"
#+end_src

**** Run me after tangle
:PROPERTIES:
:header-args+: :var CI_SERVER=tbl-input-parameters[7,2]
:header-args+: :var CD_SERVER=tbl-input-parameters[9,2]
:END:

Remember to run me with C -c C - c after tangling the files:

#+begin_src bash :shebang #!/usr/bin/env bash :tangle no
set -eou pipefail

[ -z $CI_SERVER ] && echo "CI_SERVER cannot be empty" && exit 2
[ -z $CD_SERVER ] && echo "CD_SERVER cannot be empty" && exit 2

[ -d $GIT_REPO_PATH/.poormanscicd ] || mkdir -p $GIT_REPO_PATH/.poormanscicd

cp scripts/setup-ci-server.sh $GIT_REPO_PATH/.poormanscicd/setup-ci-server-$CI_SERVER.sh
cp scripts/unsetup-ci-server.sh $GIT_REPO_PATH/.poormanscicd/unsetup-ci-server-$CI_SERVER.sh
cp scripts/setup-cd-server.sh $GIT_REPO_PATH/.poormanscicd/setup-cd-server-$CD_SERVER.sh
cp scripts/unsetup-cd-server.sh $GIT_REPO_PATH/.poormanscicd/unsetup-cd-server-$CD_SERVER.sh
cp scripts/setup-cicd-local.sh $GIT_REPO_PATH/.poormanscicd/setup-cicd-local-$CI_SERVER-$CD_SERVER.sh

#git -C "$GIT_REPO_PATH" add .poormanscicd/setup-ci-server-$CI_SERVER.sh
#git -C "$GIT_REPO_PATH" add .poormanscicd/setup-cd-server-$CD_SERVER.sh
#git -C "$GIT_REPO_PATH" add .poormanscicd/setup-cicd-local-$CI_SERVER-$CD_SERVER.sh

#git -C "$GIT_REPO_PATH" commit -m "add CI on $CI_SERVER and CD on $CD_SERVER support."
#+end_src

#+RESULTS:
